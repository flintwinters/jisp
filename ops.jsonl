{"op": "get", "args": {"type": "array", "items": {"oneOf": [{"type": "string"}, {"type": "array", "items": {"type": ["string", "number"]}}]}}, "output": {}, "doc": "Retrieves values from variables. Can be called in three ways: 1. No arguments: pops a path (string or array) from the stack. 2. One argument: uses the argument as a path. 3. Multiple arguments: treats each argument as a path and retrieves all of them, pushing them to the stack in order."}
{"op": "set", "args": {"type": "array", "items": {"oneOf": [{"type": "string"}, {"type": "array", "items": {"type": ["string", "number"]}}]}}, "output": {"type": "null"}, "doc": "Assigns values to variables. Can be called in three ways: 1. No arguments: pops a value, then a path from the stack. 2. One argument: pops a value and assigns it to the specified path. 3. Multiple arguments: pops a value for each specified path and assigns them in LIFO order."}
{"op": "exists", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {"type": "array", "items": {"type": ["string", "number"]}}}, "output": {"type": "boolean"}, "doc": "Return true if the given JSON path exists."}
{"op": "delete", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {"type": "array", "items": {"type": ["string", "number"]}}}, "output": {"type": "null"}, "doc": "Remove a key or index from the given JSON path."}
{"op": "push", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {}}, "output": {"type": "null"}, "doc": "Push a value onto the operand stack."}
{"op": "pop", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {"type": "string"}}, "output": {"type": "null"}, "doc": "Pop the top value from the operand stack and move it to the program state field specified by the argument."}
{"op": "eq", "args": {"type": "array", "minItems": 2, "maxItems": 2, "items": [{}, {}]}, "output": {"type": "boolean"}, "doc": "Return true if two values are strictly equal."}
{"op": "lt", "args": {"type": "array", "minItems": 2, "maxItems": 2, "items": [{"type": ["number", "string"]}, {"type": ["number", "string"]}]}, "output": {"type": "boolean"}, "doc": "Return true if a < b."}
{"op": "gt", "args": {"type": "array", "minItems": 2, "maxItems": 2, "items": [{"type": ["number", "string"]}, {"type": ["number", "string"]}]}, "output": {"type": "boolean"}, "doc": "Return true if a > b."}
{"op": "sub", "args": {"type": "array", "minItems": 2, "maxItems": 2, "items": [{"type": "number"}, {"type": "number"}]}, "output": {"type": "number"}, "doc": "Return a - b."}
{"op": "add", "args": {"type": "array", "minItems": 2, "maxItems": 2, "items": [{"type": "number"}, {"type": "number"}]}, "output": {"type": "number"}, "doc": "Return a + b."}
{"op": "and", "args": {"type": "array", "minItems": 2, "maxItems": 2, "items": [{"type": "boolean"}, {"type": "boolean"}]}, "output": {"type": "boolean"}, "doc": "Logical AND."}
{"op": "or", "args": {"type": "array", "minItems": 2, "maxItems": 2, "items": [{"type": "boolean"}, {"type": "boolean"}]}, "output": {"type": "boolean"}, "doc": "Logical OR."}
{"op": "not", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {"type": "boolean"}}, "output": {"type": "boolean"}, "doc": "Logical NOT."}
{"op": "if", "args": {"type": "array", "minItems": 1, "maxItems": 2, "items": [{"type": "array", "items": {"type": "object"}}, {"type": "array", "items": {"type": "object"}}]}, "output": {"type": "null"}, "doc": "Conditionally execute steps based on a boolean condition popped from the stack. The arguments are the 'then' and optionally 'else' bodies (arrays of JispOperations)."}
{"op": "call", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {"type": "string"}}, "output": {"type": "null"}, "doc": "Jump to a named workflow label and push a return point to the frame stack."}
{"op": "return", "args": {"type": "array", "maxItems": 0}, "output": {"type": "null"}, "doc": "Return execution to the most recent call frame."}
{"op": "for", "args": {"type": "array", "minItems": 3, "maxItems": 3, "items": [{"type": "string"}, {}, {"type": "array", "items": {"type": "object"}}]}, "output": {"type": "null"}, "doc": "Iterate over an array or object: bind each element/key to the specified variable and execute the body for each iteration."}{"op": "while", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {"type": "array", "items": {"type": ["string", "number"]}}}, "output": {"type": "null"}, "doc": "Repeatedly check the value at `path`; while truthy, execute `body` each iteration."}
{"op": "foreach", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {}}, "output": {"type": "null"}, "doc": "Alias for `for` that emphasizes iterating key/value pairs for objects or elements for arrays; binds each element to `var` and runs `body`."}
{"op": "while", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {"type": "array", "items": {"type": ["string", "number"]}}}, "output": {"type": "null"}, "doc": "Repeatedly check the value at `path`; while truthy, execute `body` each iteration."}
{"op": "break", "args": {"type": "array", "maxItems": 0}, "output": {"type": "null"}, "doc": "Exit the nearest enclosing loop immediately (for/while)."}
{"op": "continue", "args": {"type": "array", "maxItems": 0}, "output": {"type": "null"}, "doc": "Skip the remainder of the current loop iteration and continue with the next iteration of the nearest enclosing loop."}
{"op": "try", "args": {"type": "array", "minItems": 2, "maxItems": 3, "items": [{"type": "array", "items": {"type": "object"}}, {"type": "string"}, {"type": "array", "items": {"type": "object"}}]}, "output": {"type": "null"}, "doc": "Execute `try` body; on error, bind exception message to `catch_var` and run `catch_body`; returns nil."}
{"op": "concat", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {"type": "array"}}, "output": {"type": "string"}, "doc": "Convert all values to strings and concatenate them."}
{"op": "to_string", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {}}, "output": {"type": "string"}, "doc": "Convert a value to its string representation."}
{"op": "upper", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {"type": "string"}}, "output": {"type": "string"}, "doc": "Convert a string to uppercase."}
{"op": "lower", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {"type": "string"}}, "output": {"type": "string"}, "doc": "Convert a string to lowercase."}
{"op": "trim", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {"type": "string"}}, "output": {"type": "string"}, "doc": "Trim leading and trailing whitespace."}
{"op": "replace", "args": {"type": "array", "minItems": 3, "maxItems": 3, "items": [{"type": "string"}, {"type": "string"}, {"type": "string"}]}, "output": {"type": "string"}, "doc": "Replace all occurrences of a substring in a string. Expects three strings on the stack: the original string, the substring to replace, and the replacement string. Pushes the modified string back to the stack."}
{"op": "len", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {"oneOf": [{"type": "string"}, {"type": "array"}, {"type": "object"}]}}, "output": {"type": "number"}, "doc": "Return length of a string/array or number of keys in an object."}
{"op": "slice", "args": {"type": "array", "minItems": 1, "maxItems": 3}, "output": {"oneOf": [{"type": "array"}, {"type": "string"}]}, "doc": "Return a slice of an array or string."}
{"op": "map", "args": {"type": "array", "maxItems": 0}, "output": {"type": "array"}, "doc": "Pops array, variable name, and map_operations from the stack. Applies map_operations to each element, binding the element to the variable name. Pushes the new array of results to the stack."}
{"op": "filter", "args": {"type": "array", "maxItems": 0}, "output": {"type": "array"}, "doc": "Pops array, variable name, and condition_operations from the stack. Filters elements that satisfy the condition, binding the element to the variable name. Pushes the new filtered array to the stack."}
{"op": "reduce", "args": {"type": "array", "maxItems": 0}, "output": {}, "doc": "Pops an array, reduce_operations, and an initial_value from the stack. For each item, pushes the accumulator and the item, then executes the operations, which should result in a new accumulator on the stack. The final accumulator value is pushed to the stack."}
{"op": "sort", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {"type": "array"}}, "output": {"type": "array"}, "doc": "Sort an array of primitives."}
{"op": "keys", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {"type": "object"}}, "output": {"type": "array", "items": {"type": "string"}}, "doc": "Return all object keys."}
{"op": "values", "args": {"type": "array", "minItems": 1, "maxItems": 1, "items": {"type": "object"}}, "output": {"type": "array"}, "doc": "Return all object values."}
{"op": "union", "args": {"type": "array", "minItems": 2, "maxItems": 2, "items": [{"type": "array"}, {"type": "array"}]}, "output": {"type": "array"}, "doc": "Pops two arrays from the stack, computes their set union, and pushes the resulting array. Elements must be primitive types (numbers, strings, booleans, null)."}
{"op": "intersection", "args": {"type": "array", "minItems": 2, "maxItems": 2, "items": [{"type": "array"}, {"type": "array"}]}, "output": {"type": "array"}, "doc": "Pops two arrays from the stack, computes their set intersection, and pushes the resulting array. Elements must be primitive types (numbers, strings, booleans, null)."}
{"op": "difference", "args": {"type": "array", "minItems": 2, "maxItems": 2, "items": [{"type": "array"}, {"type": "array"}]}, "output": {"type": "array"}, "doc": "Pops two arrays (array1, array2) from the stack, computes their set difference (elements in array1 but not in array2), and pushes the resulting array. Elements must be primitive types (numbers, strings, booleans, null)."}
{"op": "join", "args": {"type": "array", "minItems": 3, "maxItems": 3, "items": [{"type": "array", "items": {"type": "object"}}, {"type": "array", "items": {"type": "object"}}, {"oneOf": [{"type": "string"}, {"type": "array", "items": {"type": "object"}}]}]}, "output": {"type": "array", "items": {"type": "object"}}, "doc": "Pops three arguments: the right array, the left array, and a join condition. Performs a relational join. The join condition can be a string (common key name for an inner join of objects) or an array of Jisp operations (for a custom condition). Pushes the resulting array of joined objects to the stack."}
{"op": "range", "args": {"type": "array", "minItems": 2, "maxItems": 3, "items": [{"type": "number"}, {"type": "number"}, {"type": "number"}]}, "output": {"type": "array", "items": {"type": "number"}}, "doc": "Generate a numeric range."}
{"op": "noop", "args": {"type": "array", "maxItems": 0}, "output": {"type": "null"}, "doc": "Perform no action."}
{"op": "valid", "args": {"type": "array", "minItems": 2, "maxItems": 2, "items": [{"type": "object"}, {}]}, "output": {"type": "boolean"}, "doc": "Validate a value against a JSON Schema."}
{"op": "raise", "args": {"type": "array", "maxItems": 0}, "output": {"type": "null"}, "doc": "Pops a string from the stack and raises an error with that message, halting execution."}
{"op": "assert", "args": {"type": "array", "minItems": 0, "maxItems": 1, "items": {"type": "string"}}, "output": {"type": "null"}, "doc": "Pops a value from the stack. If the value is false, raises an error with an optional custom message from the arguments. If no message is provided, a default 'assertion failed' error is used."}
